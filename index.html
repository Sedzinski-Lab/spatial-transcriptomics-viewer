<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>ST Viewer (TIFF + Transcripts + Mask + Rotation + ROIs)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body{margin:0;font-family:system-ui,Segoe UI,Arial;background:#111;color:#eee;display:flex;min-height:100vh}
  .left{width:400px;background:#1a1a1a;border-right:1px solid #2a2a2a;padding:14px;box-sizing:border-box}
  .right{flex:1;position:relative}
  h1{font-size:18px;margin:0 0 10px}
  .box{border:1px solid #2a2a2a;border-radius:8px;padding:10px;margin-bottom:12px;background:#181818}
  label{display:block;font-size:12px;color:#bbb;margin:6px 0 4px}
  input[type=file],select,button,input[type=range]{width:100%}
  input[type=file]{padding:8px;border-radius:6px;background:#101010;border:1px dashed #333;color:#bbb}
  select{padding:8px;border-radius:6px;background:#101010;border:1px solid #333;color:#ddd}
  button{padding:8px;border-radius:6px;background:#4a6cff;border:none;color:white;font-weight:600;cursor:pointer}
  button:disabled{opacity:.5;cursor:not-allowed}
  .row{display:flex;gap:8px}
  .row>*{flex:1}
  .status{font-size:12px;color:#aaa;margin-top:6px;min-height:16px}
  .overlayInfo{position:absolute;left:8px;top:8px;background:rgba(0,0,0,.55);padding:4px 8px;border-radius:6px;font-size:12px}
  canvas{position:absolute;left:0;top:0}
  .wide { width: 100%; margin-top: 8px; }

  .muted{color:#aaa;font-size:12px}

  /* Gene list */
  .genes{max-height:260px;overflow:auto;border:1px solid #2a2a2a;border-radius:6px;margin-top:10px}
  .geneRow{border-bottom:1px solid #222;padding:8px}
  .geneRow:last-child{border-bottom:none}
  .geneHead{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .geneName{font-weight:600}
  .geneTools{display:flex;align-items:center;gap:8px}
  .geneTools input[type=color]{width:28px;height:22px;border:none;background:transparent;cursor:pointer}
  .geneControls{display:grid;grid-template-columns:auto 1fr auto;gap:6px;align-items:center;margin-top:6px}

  /* ROI list */
  .polys{max-height:260px;overflow:auto;border:1px solid #2a2a2a;border-radius:6px;margin-top:8px}
  .polyItem{border-bottom:1px solid #222;padding:6px 8px}
  .polyItem:last-child{border-bottom:none}
  .polyItem.selected{background:#232323}
  .polyHead{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .polyBtns{display:flex;gap:6px}

  /* Mask controls area */
  .maskRow{display:grid;grid-template-columns:auto 1fr auto;gap:6px;align-items:center}

  /* Floating cell-type widget */
  #cellTypePop{
    position:absolute; display:none; z-index:50;
    background:#202020; border:1px solid #333; border-radius:8px;
    padding:8px; box-shadow:0 10px 30px rgba(0,0,0,.6);
  }
  #cellTypePop .row{ display:flex; align-items:center; gap:6px }
  #cellTypePop input[type=text]{ width:140px }
  #cellTypePop button{ padding:6px 10px }
</style>
</head>
<body>
  <div class="left">
    <h1>ST Viewer</h1>

    <div class="box">
      <label>DAPI image (TIFF/PNG/JPG)</label>
      <input id="dapiFile" type="file" accept=".tif,.tiff,.png,.jpg,.jpeg">

      <label style="margin-top:10px">Segmentation mask (TIFF/PNG)</label>
      <input id="maskFile" type="file" accept=".tif,.tiff,.png">

      <label style="margin-top:10px">Transcripts (TXT/TSV/CSV)</label>
      <input id="trFile" type="file" accept=".txt,.tsv,.csv">

      <div class="status" id="status">Pick files to start…</div>
    </div>

    <div class="box">
      <label>DAPI contrast (percentile stretch)</label>
      <div class="maskRow">
        <span class="muted">Low %</span>
        <input id="dapiLow" type="range" min="0" max="20" value="2">
        <span id="dapiLowVal">2%</span>
      </div>
      <div class="maskRow">
        <span class="muted">High %</span>
        <input id="dapiHigh" type="range" min="80" max="100" value="98">
        <span id="dapiHighVal">98%</span>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="dapiAutoBtn">Auto 2–98%</button>
      </div>
      <div class="muted" style="margin-top:6px">Adjust to reveal nuclei. Works for both TIFF and PNG/JPG.</div>
    </div>

    <div class="box">
      <label>Select gene</label>
      <select id="geneSelect" disabled><option>Load transcripts first</option></select>
      <button id="addGeneBtn" disabled>Add Gene Layer</button>

      <div class="row" style="margin-top:8px">
        <div>
          <label>Default size (new layers)</label>
          <input id="defaultSize" type="range" min="1" max="25" value="5">
        </div>
        <div>
          <label>Default opacity (new layers)</label>
          <input id="defaultOpacity" type="range" min="10" max="100" value="80">
        </div>
      </div>

      <div class="genes" id="geneList"></div>
    </div>

    <div class="box">
      <label>Mask overlay</label>
      <div class="row" style="margin-bottom:8px">
        <label style="display:flex;align-items:center;gap:6px">
          <input type="checkbox" id="maskShowFill" checked> Show fill
        </label>
        <label style="display:flex;align-items:center;gap:6px">
          <input type="checkbox" id="maskShowEdges" checked> Show edges
        </label>
      </div>
      <div class="maskRow">
        <span class="muted">Mask opacity</span>
        <input id="maskOpacity" type="range" min="5" max="100" value="30">
        <span id="maskOpacityVal">30%</span>
      </div>
      <div class="muted" style="margin-top:6px">
        Mask must be aligned to DAPI and use the same coordinate system.
      </div>
    </div>

    <div class="box">
      <label>Annotations (polygon ROIs)</label>
      <div class="row" style="margin-bottom:8px">
        <button id="drawBtn">Draw</button>
        <button id="completeBtn" disabled>Complete</button>
        <button id="cancelBtn" disabled>Cancel</button>
      </div>
      <div class="row" style="margin-bottom:8px">
        <button id="exportJsonBtn">Export JSON</button>
        <button id="exportCsvBtn">Export CSV</button>
      </div>
      <div class="polys" id="polyList"></div>
      <div class="muted" style="margin-top:6px">
        Click to add vertices. Double-click to finish. Esc to cancel.<br>
        Click an ROI on the image to select it. Press T to open cell-type selector. Delete to remove.
      </div>
    </div>

    <div class="box">
      <div class="muted">
        View controls:<br>
        • Wheel = zoom at cursor · Drag = pan<br>
        • Hold R + drag = rotate around image center<br>
        • Reset View fits and sets angle to 0
      </div>
      <button id="resetViewBtn" class="wide">Reset View</button>
    </div>
  </div>

  <div class="right">
    <div class="overlayInfo" id="info">0 layers</div>
    <canvas id="dapi"></canvas>
    <canvas id="mask"></canvas>
    <canvas id="points"></canvas>
    <canvas id="poly"></canvas>

    <!-- Floating cell-type selector -->
    <div id="cellTypePop">
      <div class="row">
        <select id="cellTypeSelect"></select>
        <input id="cellTypeOther" type="text" placeholder="type new…" style="display:none">
        <button id="cellTypeSave" style="display:none">Save</button>
        <button id="cellTypeClose" title="Close">×</button>
      </div>
    </div>
  </div>

  <!-- GeoTIFF decoder -->
  <script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.3/dist-browser/geotiff.min.js"></script>

  <script>
  (function(){
    // Canvases and contexts
    const dapiCanvas = document.getElementById('dapi');
    const maskCanvas = document.getElementById('mask');
    const ptsCanvas  = document.getElementById('points');
    const polyCanvas = document.getElementById('poly');
    const dctx = dapiCanvas.getContext('2d');
    const mctx = maskCanvas.getContext('2d');
    const pctx = ptsCanvas.getContext('2d');
    const xctx = polyCanvas.getContext('2d'); // polygons
    const container = document.querySelector('.right');
    const info = document.getElementById('info');

    // Files UI
    const statusEl = document.getElementById('status');

    // Data: DAPI
    let dapiW = 0, dapiH = 0;
    let dapiRaw = null;     // { w,h, gray: Float32Array(0..1), sorted: Float32Array(0..1) }
    let dapiBitmap = null;  // ImageBitmap for fast draw
    let dapiLowPct = 2, dapiHighPct = 98;

    // Data: transcripts / layers
    let transcripts = [];      // {x,y,z,gene,score}
    let genes = [];            // gene list
    // gene -> {data,color,size,opacity,visible}
    const layers = new Map();

    // Segmentation mask state
    let mask = null; // {w,h, labels:Uint32Array, fillBitmap:ImageBitmap, edgeBitmap:ImageBitmap, opacity, showFill, showEdges}

    // ROI state: polygons: {id,name,cellType,verts:[{x,y}], total, counts:{}}
    let polygons = [];
    let activePoly = null;
    let selectedPolyId = null;
    let drawMode = false;
    let nextPolyId = 1;

    // Cell-type options (customs will be inserted before "Other…")
    let cellTypes = ["", "MCC", "Goblet", "IC", "Basal", "SSC", "Other…"];

    // Defaults for new gene layers
    let defaultSize = 5;
    let defaultOpacity = 0.8;

    // Viewport (pan/zoom/rotation)
    let scale = 1, offX = 0, offY = 0;
    let angle = 0; // radians
    let pivot = { x: 0, y: 0 }; // rotation pivot in world coords
    let dragging=false, lastX=0, lastY=0;

    // Rotation interaction
    let rKey = false;
    let rotating = false;
    let rotStartAngle = 0;     // angle at start of drag
    let rotRefTheta = 0;       // angle from pivot to initial mouse world point

    function setStatus(t){ statusEl.textContent = t; }

    // ---------- Resize ----------
    function resize(){
      const r = container.getBoundingClientRect();
      [dapiCanvas, maskCanvas, ptsCanvas, polyCanvas].forEach(c=>{
        c.width = r.width; c.height = r.height; c.style.width = r.width+'px'; c.style.height = r.height+'px';
      });
      redraw();
    }
    window.addEventListener('resize', resize);

    // ---------- DAPI contrast UI ----------
    const dapiLowEl  = document.getElementById('dapiLow');
    const dapiHighEl = document.getElementById('dapiHigh');
    const dapiLowValEl  = document.getElementById('dapiLowVal');
    const dapiHighValEl = document.getElementById('dapiHighVal');
    const dapiAutoBtn = document.getElementById('dapiAutoBtn');

    dapiLowEl.addEventListener('input', ()=>{
      let v = +dapiLowEl.value;
      if (v >= dapiHighPct-1) v = dapiHighPct-1;
      dapiLowPct = Math.max(0, v);
      dapiLowEl.value = String(dapiLowPct);
      dapiLowValEl.textContent = dapiLowPct + '%';
      rebuildDapiBitmap(); redraw();
    });
    dapiHighEl.addEventListener('input', ()=>{
      let v = +dapiHighEl.value;
      if (v <= dapiLowPct+1) v = dapiLowPct+1;
      dapiHighPct = Math.min(100, v);
      dapiHighEl.value = String(dapiHighPct);
      dapiHighValEl.textContent = dapiHighPct + '%';
      rebuildDapiBitmap(); redraw();
    });
    dapiAutoBtn.addEventListener('click', ()=>{
      dapiLowPct = 2; dapiHighPct = 98;
      dapiLowEl.value = '2'; dapiHighEl.value='98';
      dapiLowValEl.textContent='2%'; dapiHighValEl.textContent='98%';
      rebuildDapiBitmap(); redraw();
    });

    // ---------- Keyboard ----------
    window.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape' && activePoly){
        activePoly = null; drawMode = false;
        document.getElementById('drawBtn').textContent='Draw';
        document.getElementById('completeBtn').disabled = true;
        document.getElementById('cancelBtn').disabled = true;
        redraw();
      }
      if ((e.key === 't' || e.key === 'T') && selectedPolyId!=null){
        const poly = polygons.find(p=>p.id===selectedPolyId);
        if (poly) openCellTypeUI(poly);
      }
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedPolyId!=null){
        deleteSelectedPoly();
      }
      if (e.key === 'r' || e.key === 'R') {
        rKey = true;
      }
    });
    window.addEventListener('keyup', (e)=>{
      if (e.key === 'r' || e.key === 'R') {
        rKey = false;
        rotating = false;
      }
    });

    // ---------- File inputs ----------
    document.getElementById('dapiFile').addEventListener('change', e=>{
      const f = e.target.files[0]; if (f) loadDAPI(f);
    });
    document.getElementById('maskFile').addEventListener('change', e=>{
      const f = e.target.files[0]; if (f) loadMask(f);
    });
    document.getElementById('trFile').addEventListener('change', e=>{
      const f = e.target.files[0]; if (f) loadTranscripts(f);
    });

    // ---------- Mask overlay UI ----------
    const maskShowFillEl = document.getElementById('maskShowFill');
    const maskShowEdgesEl = document.getElementById('maskShowEdges');
    const maskOpacityEl = document.getElementById('maskOpacity');
    const maskOpacityValEl = document.getElementById('maskOpacityVal');

    maskShowFillEl.addEventListener('change', ()=>{ if (mask){ mask.showFill = maskShowFillEl.checked; redraw(); } });
    maskShowEdgesEl.addEventListener('change', ()=>{ if (mask){ mask.showEdges = maskShowEdgesEl.checked; redraw(); } });
    maskOpacityEl.addEventListener('input', ()=>{
      const v = (+maskOpacityEl.value)/100;
      maskOpacityValEl.textContent = maskOpacityEl.value + '%';
      if (mask){ mask.opacity = v; redraw(); }
    });

    // ---------- Gene UI ----------
    document.getElementById('addGeneBtn').addEventListener('click', ()=>{
      const g = document.getElementById('geneSelect').value;
      if (!g) return;
      if (layers.has(g)) { setStatus(g+' already added'); return; }
      const pts = transcripts.filter(r=>r.gene===g);
      const col = randColorHex();
      const layer = {
        color: col,
        size: defaultSize,
        opacity: defaultOpacity,
        visible: true,
        data: pts
      };
      layers.set(g, layer);
      addGeneRow(g, layer);
      redraw();
      setStatus(`Added ${pts.length} points for ${g}`);
    });

    function addGeneRow(gene, layer){
      const list = document.getElementById('geneList');
      const row = document.createElement('div');
      row.className='geneRow';
      row.innerHTML = `
        <div class="geneHead">
          <div class="geneName">${gene}</div>
          <div class="geneTools">
            <input type="color" value="${layer.color}" title="Color">
            <button class="toggleBtn" style="padding:4px 8px">${layer.visible?'Hide':'Show'}</button>
          </div>
        </div>
        <div class="geneControls">
          <span class="muted">Size</span>
          <input class="sizeRange" type="range" min="1" max="25" value="${layer.size}">
          <span class="sizeVal">${layer.size}</span>

          <span class="muted">Opacity</span>
          <input class="opRange" type="range" min="10" max="100" value="${Math.round(layer.opacity*100)}">
          <span class="opVal">${Math.round(layer.opacity*100)}%</span>
        </div>
      `;

      const colorInput = row.querySelector('input[type=color]');
      const toggleBtn = row.querySelector('.toggleBtn');
      const sizeRange = row.querySelector('.sizeRange');
      const opRange = row.querySelector('.opRange');
      const sizeVal = row.querySelector('.sizeVal');
      const opVal = row.querySelector('.opVal');

      colorInput.oninput = (e)=>{ layers.get(gene).color = e.target.value; redraw(); };
      toggleBtn.onclick = ()=>{
        const L = layers.get(gene);
        L.visible=!L.visible; toggleBtn.textContent = L.visible?'Hide':'Show';
        redraw();
      };
      sizeRange.oninput = (e)=>{
        const v = +e.target.value; sizeVal.textContent = v;
        layers.get(gene).size = v; redraw();
      };
      opRange.oninput = (e)=>{
        const v = +e.target.value; opVal.textContent = v+'%';
        layers.get(gene).opacity = v/100; redraw();
      };

      list.appendChild(row);
    }

    document.getElementById('defaultSize').addEventListener('input', e=>{
      defaultSize = +e.target.value;
    });
    document.getElementById('defaultOpacity').addEventListener('input', e=>{
      defaultOpacity = +e.target.value / 100;
    });

    // ---------- Pan/Zoom/Rotate & Draw & Select on TOP canvas ----------
    polyCanvas.addEventListener('mousedown', (e)=>{
      const rect = polyCanvas.getBoundingClientRect();
      const x = e.clientX-rect.left, y=e.clientY-rect.top;
      if (rKey){
        // Start rotation around image center
        rotating = true;
        setPivotToImageCenter();
        const ptW = screenToWorld(x,y);
        rotRefTheta = Math.atan2(ptW.y - pivot.y, ptW.x - pivot.x);
        rotStartAngle = angle;
        return;
      }

      if (drawMode){
        const pt = screenToWorld(x,y);
        if (!activePoly) {
          activePoly = { id: nextPolyId++, name: `ROI ${nextPolyId-1}`, cellType: '', verts: [pt], counts:{}, total:0 };
        } else {
          activePoly.verts.push(pt);
        }
        redraw();
        document.getElementById('completeBtn').disabled = (activePoly.verts.length<3);
        document.getElementById('cancelBtn').disabled = false;
      } else {
        // begin pan
        dragging=true; lastX=e.clientX; lastY=e.clientY;
      }
    });

    window.addEventListener('mouseup', (e)=>{
      if (rotating){ rotating=false; return; }
      // if minimal movement, treat as click-select
      if (dragging && Math.abs(e.clientX-lastX)<2 && Math.abs(e.clientY-lastY)<2 && !drawMode){
        const rect = polyCanvas.getBoundingClientRect();
        const x = e.clientX-rect.left, y=e.clientY-rect.top;
        handleClickSelect(x,y);
      }
      dragging=false;
    });

    window.addEventListener('mousemove', (e)=>{
      if (rotating){
        const rect = polyCanvas.getBoundingClientRect();
        const x = e.clientX-rect.left, y=e.clientY-rect.top;
        const ptW = screenToWorld(x,y);
        const theta = Math.atan2(ptW.y - pivot.y, ptW.x - pivot.x);
        angle = rotStartAngle + (theta - rotRefTheta);
        redraw();
        return;
      }
      if (!dragging || drawMode) return;
      offX += (e.clientX-lastX);
      offY += (e.clientY-lastY);
      lastX = e.clientX; lastY = e.clientY;
      redraw();
    });

    // zoom at cursor keeping world point fixed
    polyCanvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      if (drawMode) return;
      const rect = polyCanvas.getBoundingClientRect();
      const cx = e.clientX-rect.left, cy=e.clientY-rect.top;
      const k = e.deltaY>0 ? 0.9 : 1.1;
      zoomAt(cx,cy,k);
    }, {passive:false});

    // finish drawing on double-click; or if not drawing, open cell-type on ROI
    polyCanvas.addEventListener('dblclick', (e)=>{
      if (drawMode && activePoly && activePoly.verts.length>=3){
        polygons.push(activePoly);
        activePoly = null; drawMode=false;
        document.getElementById('drawBtn').textContent='Draw';
        document.getElementById('completeBtn').disabled = true;
        document.getElementById('cancelBtn').disabled = true;
        recomputeAllCounts();
        redraw();
        renderPolyList();
      } else if (!drawMode){
        const rect = polyCanvas.getBoundingClientRect();
        const x = e.clientX-rect.left, y=e.clientY-rect.top;
        const imgPt = screenToWorld(x,y);
        const hit = hitTestPolygons(imgPt.x, imgPt.y);
        if (hit){
          selectedPolyId = hit.id;
          renderPolyList(); redraw();
          openCellTypeUI(hit);
        }
      }
    });

    // Reset view
    document.getElementById('resetViewBtn').addEventListener('click', ()=>{
      fitView(true);
      redraw();
    });

    function handleClickSelect(x,y){
      const imgPt = screenToWorld(x,y);
      const hit = hitTestPolygons(imgPt.x, imgPt.y);
      if (hit){
        selectedPolyId = hit.id;
        renderPolyList(true);
        redraw();
        openCellTypeUI(hit);
      } else {
        closeCellTypeUI();
        if (selectedPolyId!=null){
          selectedPolyId = null;
          renderPolyList();
          redraw();
        }
      }
    }

    function hitTestPolygons(ix,iy){
      for (let k=polygons.length-1; k>=0; k--){
        const poly = polygons[k];
        if (pointInPoly(ix,iy,poly.verts)) return poly;
      }
      return null;
    }

    // Annotation buttons
    document.getElementById('drawBtn').addEventListener('click', ()=>{
      drawMode = !drawMode;
      document.getElementById('drawBtn').textContent = drawMode ? 'Stop Drawing' : 'Draw';
      if (!drawMode){
        activePoly=null;
        document.getElementById('completeBtn').disabled = true;
        document.getElementById('cancelBtn').disabled = true;
        redraw();
      } else {
        closeCellTypeUI();
      }
    });
    document.getElementById('completeBtn').addEventListener('click', ()=>{
      if (activePoly && activePoly.verts.length>=3){
        polygons.push(activePoly);
        activePoly=null; drawMode=false;
        document.getElementById('drawBtn').textContent='Draw';
        document.getElementById('completeBtn').disabled = true;
        document.getElementById('cancelBtn').disabled = true;
        recomputeAllCounts();
        redraw();
        renderPolyList();
      }
    });
    document.getElementById('cancelBtn').addEventListener('click', ()=>{
      activePoly=null; drawMode=false;
      document.getElementById('drawBtn').textContent='Draw';
      document.getElementById('completeBtn').disabled = true;
      document.getElementById('cancelBtn').disabled = true;
      redraw();
    });

    document.getElementById('exportJsonBtn').addEventListener('click', exportPolysJSON);
    document.getElementById('exportCsvBtn').addEventListener('click', exportCountsCSV);

    // ---------- Floating cell-type UI ----------
    const pop = document.getElementById('cellTypePop');
    const cellTypeSelect = document.getElementById('cellTypeSelect');
    const cellTypeOther  = document.getElementById('cellTypeOther');
    const cellTypeSave   = document.getElementById('cellTypeSave');
    const cellTypeClose  = document.getElementById('cellTypeClose');
    let cellTypeUI = { visible:false, polyId:null };

    function buildCellTypeOptions(current){
      const list = [...new Set([current || '', ...cellTypes])]; // include current if custom
      return list.map(ct=>{
        const value = (ct === 'Other…') ? '__other__' : ct;
        const label = ct === '' ? '(unset)' : ct;
        const sel = ((current || '') === ct) ? ' selected' : '';
        return '<option value="'+value+'"'+sel+'>'+label+'</option>';
      }).join('');
    }
    function polyCentroid(poly){
      let x=0, y=0; const n = Math.max(1, poly.verts.length);
      for (const v of poly.verts){ x+=v.x; y+=v.y; }
      return { x:x/n, y:y/n };
    }
    function positionCellTypeUI(poly){
      const c = polyCentroid(poly);
      const sc = worldToScreen(c.x, c.y);
      pop.style.left = Math.round(sc.x + 8) + 'px';
      pop.style.top  = Math.round(sc.y - 8) + 'px';
    }
    function openCellTypeUI(poly){
      selectedPolyId = poly.id;
      cellTypeSelect.innerHTML = buildCellTypeOptions(poly.cellType || '');
      cellTypeOther.style.display = 'none';
      cellTypeSave.style.display  = 'none';
      positionCellTypeUI(poly);
      pop.style.display = 'block';
      cellTypeUI = { visible:true, polyId: poly.id };
      cellTypeSelect.focus();
    }
    function closeCellTypeUI(){
      pop.style.display = 'none';
      cellTypeUI = { visible:false, polyId:null };
    }

    cellTypeSelect.onchange = function(){
      const v = this.value;
      const poly = polygons.find(p=>p.id === cellTypeUI.polyId);
      if (!poly) return;
      if (v === '__other__'){
        cellTypeOther.style.display = 'inline-block';
        cellTypeSave.style.display  = 'inline-block';
        cellTypeOther.value = '';
        cellTypeOther.focus();
      } else {
        poly.cellType = v;
        renderPolyList(); redraw();
      }
    };
    cellTypeSave.onclick = function(){
      const name = cellTypeOther.value.trim();
      if (!name) return;
      if (!cellTypes.includes(name)){
        const i = Math.max(0, cellTypes.indexOf('Other…'));
        cellTypes.splice(i, 0, name); // insert before Other…
      }
      const poly = polygons.find(p=>p.id === cellTypeUI.polyId);
      if (!poly) return;
      poly.cellType = name;
      renderPolyList(); redraw();
      closeCellTypeUI();
    };
    cellTypeClose.onclick = closeCellTypeUI;

    // Close on Esc if open (in addition to drawing Esc handler)
    window.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape' && cellTypeUI.visible){ closeCellTypeUI(); }
    });
    // Click outside popup closes it (but allow clicks on poly canvas)
    document.addEventListener('mousedown', (e)=>{
      if (cellTypeUI.visible && !pop.contains(e.target) && e.target !== polyCanvas){
        closeCellTypeUI();
      }
    });

    // ---------- Rendering ----------
    function redraw(){
      // clear all
      [dctx, mctx, pctx, xctx].forEach(ctx=>ctx.setTransform(1,0,0,1,0,0));
      dctx.clearRect(0,0,dapiCanvas.width,dapiCanvas.height);
      mctx.clearRect(0,0,maskCanvas.width,maskCanvas.height);
      pctx.clearRect(0,0,ptsCanvas.width,ptsCanvas.height);
      xctx.clearRect(0,0,polyCanvas.width,polyCanvas.height);

      // DAPI
      if (dapiBitmap){
        applyView(dctx);
        dctx.drawImage(dapiBitmap, 0, 0);
        dctx.setTransform(1,0,0,1,0,0);
      }

      // Mask
      if (mask){
        applyView(mctx);
        if (mask.showFill && mask.fillBitmap){
          mctx.globalAlpha = mask.opacity ?? 0.3;
          mctx.drawImage(mask.fillBitmap, 0, 0);
        }
        if (mask.showEdges && mask.edgeBitmap){
          mctx.globalAlpha = 1;
          mctx.drawImage(mask.edgeBitmap, 0, 0);
        }
        mctx.setTransform(1,0,0,1,0,0);
      }

      // Points per gene layer
      applyView(pctx);
      const s = 1/scale;
      layers.forEach(L=>{
        if (!L.visible) return;
        pctx.globalAlpha = L.opacity;
        pctx.fillStyle = L.color;
        const r = L.size*s;
        for (const pt of L.data){
          pctx.beginPath();
          pctx.arc(pt.x, pt.y, r, 0, Math.PI*2);
          pctx.fill();
        }
      });
      pctx.setTransform(1,0,0,1,0,0);

      // Polygons overlay
      applyView(xctx);
      xctx.lineWidth = 2/scale;
      for (const poly of polygons){
        const sel = (poly.id === selectedPolyId);
        const stroke = sel ? '#ffd54a' : '#00e0ff';
        const fill = sel ? 'rgba(255,213,74,0.22)' : 'rgba(0,255,255,0.18)';
        const lw = sel ? 3/scale : 2/scale;
        drawPolyShape(xctx, poly.verts, fill, stroke, false, lw);
        drawPolyLabel(xctx, poly, sel);
      }
      if (activePoly){
        drawPolyShape(xctx, activePoly.verts, 'rgba(255,255,255,0.12)', '#ffffff', true, 2/scale);
      }
      xctx.setTransform(1,0,0,1,0,0);

      // keep floating cell-type UI positioned
      if (cellTypeUI.visible){
        const poly = polygons.find(p=>p.id === cellTypeUI.polyId);
        if (poly) positionCellTypeUI(poly); else closeCellTypeUI();
      }

      const selText = selectedPolyId!=null ? ` · ROI ${selectedPolyId} selected` : '';
      const deg = (angle*180/Math.PI).toFixed(1);
      info.textContent = `${[...layers.values()].filter(L=>L.visible).length} visible layer(s) · scale ${scale.toFixed(2)} · angle ${deg}°${selText}`;
    }

    function applyView(ctx){
      // screen = T(off) * S(scale) * T(pivot) * R(angle) * T(-pivot) * world
      ctx.setTransform(1,0,0,1,0,0);
      ctx.translate(offX, offY);
      ctx.scale(scale, scale);
      ctx.translate(pivot.x, pivot.y);
      ctx.rotate(angle);
      ctx.translate(-pivot.x, -pivot.y);
    }

    function worldToScreen(wx, wy){
      let x = wx, y = wy;
      x -= pivot.x; y -= pivot.y;
      const ca = Math.cos(angle), sa = Math.sin(angle);
      const xr =  ca*x - sa*y;
      const yr =  sa*x + ca*y;
      x = xr + pivot.x; y = yr + pivot.y;
      const sx = offX + x*scale;
      const sy = offY + y*scale;
      return { x: sx, y: sy };
    }

    function screenToWorld(sx,sy){
      let x = sx - offX, y = sy - offY;
      x /= scale; y /= scale;
      x -= pivot.x; y -= pivot.y;
      const ca = Math.cos(-angle), sa = Math.sin(-angle);
      const xr = ca*x - sa*y;
      const yr = sa*x + ca*y;
      x = xr + pivot.x; y = yr + pivot.y;
      return { x, y };
    }

    function drawPolyShape(ctx, verts, fill, stroke, open=false, lineW=2){
      if (!verts.length) return;
      ctx.beginPath();
      ctx.moveTo(verts[0].x, verts[0].y);
      for (let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x, verts[i].y);
      if (!open && verts.length>=3) ctx.closePath();
      ctx.strokeStyle = stroke;
      ctx.fillStyle = fill;
      ctx.lineWidth = lineW;
      if (!open && verts.length>=3) ctx.fill();
      ctx.stroke();

      // vertices
      for (const v of verts){
        ctx.beginPath();
        ctx.arc(v.x, v.y, 3/scale, 0, Math.PI*2);
        ctx.fillStyle = stroke;
        ctx.fill();
      }
    }

    function drawPolyLabel(ctx, poly, selected){
      if (!poly.verts.length) return;
      let cx=0, cy=0;
      for (const v of poly.verts){ cx+=v.x; cy+=v.y; }
      cx/=poly.verts.length; cy/=poly.verts.length;
      const title = poly.name || `ROI ${poly.id}`;
      const n = (poly.total != null) ? ` (n=${poly.total})` : '';
      const label = poly.cellType ? `${title} • ${poly.cellType}${n}` : `${title}${n}`;
      ctx.font = `${12/scale}px system-ui,Segoe UI,Arial`;
      ctx.lineWidth = 2/scale;
      ctx.strokeStyle = 'black';
      ctx.fillStyle = selected ? 'yellow' : 'white';
      ctx.strokeText(label, cx+6/scale, cy-6/scale);
      ctx.fillText(label,   cx+6/scale, cy-6/scale);
    }

    // ---------- Geometry / helpers ----------
    function pointInPoly(px,py,verts){
      let inside=false;
      for (let i=0,j=verts.length-1;i<verts.length;j=i++){
        const xi=verts[i].x, yi=verts[i].y, xj=verts[j].x, yj=verts[j].y;
        const inter = ((yi>py)!==(yj>py)) && (px < ((xj-xi)*(py-yi))/(yj-yi) + xi);
        if (inter) inside=!inside;
      }
      return inside;
    }

    function zoomAt(cx,cy,k){
      const worldBefore = screenToWorld(cx,cy);
      const ns = Math.max(0.1, Math.min(20, scale*k));
      scale = ns;
      const screenAfter = worldToScreen(worldBefore.x, worldBefore.y);
      offX += (cx - screenAfter.x);
      offY += (cy - screenAfter.y);
      redraw();
    }

    // ---------- Counts over ALL transcripts ----------
    function countAllForPoly(poly){
      const counts = Object.create(null);
      let total = 0;
      for (const p of transcripts){
        if (pointInPoly(p.x, p.y, poly.verts)){
          total++;
          counts[p.gene] = (counts[p.gene] || 0) + 1;
        }
      }
      return { total, counts };
    }

    function recomputeAllCounts(){
      for (const poly of polygons){
        const { total, counts } = countAllForPoly(poly);
        poly.total = total;
        poly.counts = counts;
      }
      renderPolyList();
    }

    function renderPolyList(scrollToSelected=false){
      const box = document.getElementById('polyList');
      box.innerHTML = '';
      for (const poly of polygons){
        const total = poly.total ?? 0;
        const div = document.createElement('div');
        div.className='polyItem';
        div.dataset.id = String(poly.id);
        if (poly.id === selectedPolyId) div.classList.add('selected');

        div.innerHTML = `
          <div class="polyHead">
            <strong>${poly.name||('ROI '+poly.id)}</strong>
            <div class="polyBtns">
              <button data-act="rename">Rename</button>
              <button data-act="delete">Delete</button>
            </div>
          </div>

          <div class="maskRow" style="margin:6px 0 4px">
            <span class="muted">Cell type</span>
            <select class="cellTypeSel"></select>
            <span class="muted">${poly.verts.length}v · <b>${total}</b> tx</span>
          </div>

          <div class="countsGrid" style="display:grid;grid-template-columns:1fr auto;gap:4px;margin-top:6px;font-size:12px"></div>
        `;

        // Build options (include current poly.cellType if it’s not in the predefined list)
        const sel = div.querySelector('.cellTypeSel');
        const hasCurrent = (poly.cellType ?? "") && !cellTypes.includes(poly.cellType);
        const opts = (hasCurrent ? [poly.cellType] : []).concat(cellTypes);

        sel.innerHTML = opts.map(ct => {
          const value = (ct === "Other…") ? "__other__" : ct;
          const label = ct === "" ? "(unset)" : ct;
          const selected = (poly.cellType || "") === ct ? ' selected' : '';
          return `<option value="${value}"${selected}>${label}</option>`;
        }).join("");

        sel.onchange = (e) => {
          const v = e.target.value;
          if (v === "__other__") {
            const nn = prompt("Enter custom cell type:", "");
            if (nn && nn.trim()) {
              const name = nn.trim();
              if (!cellTypes.includes(name)) {
                const idx = Math.max(0, cellTypes.indexOf("Other…"));
                cellTypes.splice(idx, 0, name);
              }
              poly.cellType = name;
              renderPolyList(); // refresh row so the new option appears selected
              redraw();
            } else {
              renderPolyList(); // revert UI
            }
          } else {
            poly.cellType = v; // may be "" for unset or any preset
            renderPolyList();
            redraw();
          }
        };

        // Counts grid (top 30)
        const grid = div.querySelector('.countsGrid');
        const entries = Object.entries(poly.counts || {}).sort((a,b)=>b[1]-a[1]);
        const MAX = 30;
        for (const [g,c] of entries.slice(0, MAX)){
          const r1 = document.createElement('div'); r1.textContent = g;
          const r2 = document.createElement('div'); r2.textContent = c; r2.style.textAlign='right';
          grid.appendChild(r1); grid.appendChild(r2);
        }
        if (entries.length > MAX){
          const more = document.createElement('div');
          more.className = 'muted';
          more.style.gridColumn = '1 / -1';
          more.textContent = `… ${entries.length - MAX} more (see CSV/JSON export)`;
          grid.appendChild(more);
        }

        div.querySelector('[data-act=rename]').onclick = ()=>{
          selectedPolyId = poly.id; const nn = prompt('Name for this ROI', poly.name||('ROI '+poly.id));
          if (nn) { poly.name = nn; renderPolyList(); redraw(); }
        };
        div.querySelector('[data-act=delete]').onclick = ()=>{
          polygons = polygons.filter(p=>p!==poly);
          if (selectedPolyId === poly.id) selectedPolyId = null;
          renderPolyList(); redraw();
        };

        // clicking a row selects the ROI
        div.onclick = ()=>{
          selectedPolyId = poly.id; renderPolyList(); redraw();
        };

        box.appendChild(div);
      }

      if (scrollToSelected && selectedPolyId!=null){
        const el = box.querySelector(`.polyItem[data-id="${selectedPolyId}"]`);
        if (el) el.scrollIntoView({ block:'nearest' });
      }
    }

    function deleteSelectedPoly(){
      const idx = polygons.findIndex(p=>p.id===selectedPolyId);
      if (idx>=0){
        polygons.splice(idx,1);
        selectedPolyId = null;
        renderPolyList(); redraw();
      }
    }

    function exportPolysJSON(){
      const payload = {
        image: (dapiW && dapiH) ? { width: dapiW, height: dapiH } : null,
        polygons: polygons.map(p=>({
          id: p.id,
          name: p.name,
          cellType: p.cellType || '',
          vertices: p.verts,
          total: p.total || 0,
          counts: p.counts||{}
        }))
      };
      const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'polygons.json'; a.click();
      URL.revokeObjectURL(url);
    }

    function exportCountsCSV(){
      const rows = [['poly_id','name','cell_type','total','gene','count']];
      for (const p of polygons){
        const nm = p.name || `ROI ${p.id}`;
        const ct = p.cellType || '';
        const total = p.total || 0;
        const entries = Object.entries(p.counts||{}).sort((a,b)=>b[1]-a[1]);
        if (entries.length === 0){
          rows.push([p.id, nm, ct, total, '', 0]);
        } else {
          for (const [g,c] of entries){
            rows.push([p.id, nm, ct, total, g, c]);
          }
        }
      }
      const csv = rows.map(r=>r.join(',')).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'polygon_counts.csv'; a.click();
      URL.revokeObjectURL(url);
    }

    // ---------- Load transcripts ----------
    async function loadTranscripts(file){
      try{
        setStatus('Loading transcripts…');
        const txt = await file.text();
        const lines = txt.trim().split(/\r?\n/);
        const out = [];
        const G = new Set();
        for (let i=0;i<lines.length;i++){
          const row = lines[i].trim();
          if (!row) continue;
          const parts = row.split(/[\t,]/);
          if (parts.length < 4) continue;
          if (i===0 && isNaN(parseFloat(parts[0]))){ continue; } // header
          const x = +parts[0], y = +parts[1], z = +(parts[2]||0);
          const gene = (parts[3]||'').trim();
          const score = +(parts[4]||1);
          if (Number.isFinite(x) && Number.isFinite(y) && gene){
            out.push({x,y,z,gene,score}); G.add(gene);
          }
        }
        transcripts = out;
        genes = Array.from(G).sort();
        const sel = document.getElementById('geneSelect');
        sel.innerHTML = '<option value="">Select a gene…</option>';
        for (const g of genes){ const o=document.createElement('option'); o.value=g; o.textContent=g; sel.appendChild(o); }
        sel.disabled = false;
        document.getElementById('addGeneBtn').disabled = false;
        setStatus(`Loaded ${out.length} transcripts for ${genes.length} genes`);
        recomputeAllCounts();
      }catch(err){
        console.error(err); setStatus('Failed to load transcripts: '+(err?.message||err));
      }
    }

    // ---------- Load DAPI (GeoTIFF/PNG/JPG) ----------
    async function loadDAPI(file){
      const name = file.name.toLowerCase();
      try{
        if (name.endsWith('.png') || name.endsWith('.jpg') || name.endsWith('.jpeg')){
          setStatus('Loading image…');
          const url = URL.createObjectURL(file);
          const img = new Image();
          img.onload = async ()=>{
            URL.revokeObjectURL(url);
            // Convert to grayscale float [0..1]
            const w = img.width, h = img.height;
            const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h;
            const tctx = tmp.getContext('2d', { willReadFrequently:true });
            tctx.drawImage(img, 0, 0);
            const id = tctx.getImageData(0,0,w,h).data;
            const gray = new Float32Array(w*h);
            for (let i=0,j=0;j<w*h;i+=4,j++){
              const r=id[i], g=id[i+1], b=id[i+2];
              gray[j] = (0.299*r + 0.587*g + 0.114*b) / 255;
            }
            const sorted = Float32Array.from(gray).sort();
            dapiRaw = { w, h, gray, sorted };
            dapiW=w; dapiH=h;
            await rebuildDapiBitmap();
            fitView(true);
            redraw();
            setStatus(`DAPI ${w}×${h} (PNG/JPG, adjustable contrast)`);
          };
          img.onerror = ()=>{ URL.revokeObjectURL(url); setStatus('Could not load image'); };
          img.src = url;
          return;
        }

        if (!(name.endsWith('.tif') || name.endsWith('.tiff'))){
          setStatus('Unsupported image type'); return;
        }

        setStatus('Decoding TIFF (GeoTIFF)…');
        const buf = await file.arrayBuffer();
        const tiff = await GeoTIFF.fromArrayBuffer(buf);

        const count = (await tiff.getImageCount?.()) ?? 1;
        let image = await tiff.getImage(0);
        if (count > 1) {
          let best = image, bestArea = image.getWidth()*image.getHeight();
          for (let i=1; i<count; i++){
            const im = await tiff.getImage(i);
            const area = im.getWidth()*im.getHeight();
            if (area > bestArea){ best = im; bestArea = area; }
          }
          image = best;
        }

        const w = image.getWidth(), h = image.getHeight();
        const spp = image.getSamplesPerPixel();
        const samples = spp >= 3 ? [0,1,2] : [0];
        const raster = await image.readRasters({ interleave: true, samples });

        const px = w*h;
        const grayF = new Float32Array(px);
        if (samples.length === 3) {
          for (let i=0,j=0; j<px; j++, i+=3) {
            const r = raster[i], g = raster[i+1], b = raster[i+2];
            grayF[j] = (0.299*r + 0.587*g + 0.114*b);
          }
          // normalize to 0..1
          let min=Infinity, max=-Infinity;
          for (let j=0;j<px;j++){ const v=grayF[j]; if (v<min) min=v; if (v>max) max=v; }
          const denom = Math.max(1e-12, max-min);
          for (let j=0;j<px;j++){ grayF[j] = (grayF[j]-min)/denom; }
        } else {
          // convert to 0..1 using min/max
          let min=Infinity, max=-Infinity;
          for (let j=0;j<px;j++){ const v=raster[j]; if (v<min) min=v; if (v>max) max=v; }
          const denom = Math.max(1e-12, max-min);
          for (let j=0;j<px;j++){ grayF[j] = (raster[j]-min)/denom; }
        }

        const sorted = Float32Array.from(grayF).sort();
        dapiRaw = { w, h, gray: grayF, sorted };
        dapiW=w; dapiH=h;
        await rebuildDapiBitmap();
        fitView(true);
        redraw();
        setStatus(`DAPI ${w}×${h} (TIFF, adjustable contrast)`);

      }catch(err){
        console.error(err);
        setStatus('Failed to load DAPI: '+(err?.message||err));
      }
    }

    async function rebuildDapiBitmap(){
      if (!dapiRaw) return;
      const { w,h,gray,sorted } = dapiRaw;
      const loIdx = Math.floor(sorted.length * (dapiLowPct/100));
      const hiIdx = Math.floor(sorted.length * (dapiHighPct/100));
      const lo = sorted[Math.max(0, Math.min(sorted.length-1, loIdx))];
      const hi = sorted[Math.max(0, Math.min(sorted.length-1, hiIdx))];
      const denom = Math.max(1e-9, hi - lo);

      const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h;
      const tctx = tmp.getContext('2d', { willReadFrequently:true });
      const imgData = tctx.createImageData(w,h);
      for (let j=0,i=0;j<w*h;j++,i+=4){
        let v = (gray[j] - lo) / denom;
        if (v < 0) v = 0; else if (v > 1) v = 1;
        const u = (v*255)|0;
        imgData.data[i] = u; imgData.data[i+1] = u; imgData.data[i+2] = u; imgData.data[i+3] = 255;
      }
      tctx.putImageData(imgData,0,0);
      dapiBitmap = await createImageBitmap(tmp);
    }

    // ---------- Load Segmentation Mask (TIFF/PNG) ----------
    async function loadMask(file){
      try{
        setStatus('Loading segmentation mask…');
        const name = file.name.toLowerCase();
        let w=0, h=0, labels=null;

        if (name.endsWith('.tif') || name.endsWith('.tiff')){
          const buf = await file.arrayBuffer();
          const tiff = await GeoTIFF.fromArrayBuffer(buf);
          const count = (await tiff.getImageCount?.()) ?? 1;
          let image = await tiff.getImage(0);
          if (count > 1) {
            let best = image, bestArea = image.getWidth()*image.getHeight();
            for (let i=1; i<count; i++){
              const im = await tiff.getImage(i);
              const area = im.getWidth()*im.getHeight();
              if (area > bestArea){ best = im; bestArea = area; }
            }
            image = best;
          }
          w = image.getWidth(); h = image.getHeight();
          const spp = image.getSamplesPerPixel();

          if (spp === 1){
            const ras = await image.readRasters({ interleave:true });
            labels = new Uint32Array(ras.length);
            for (let i=0;i<ras.length;i++) labels[i] = ras[i] >>> 0;
          } else {
            const ras = await image.readRasters({ interleave:true, samples:[0,1,2] });
            labels = colorToLabelsFromInterleavedRGB(ras, w, h);
          }
        } else if (name.endsWith('.png')){
          const url = URL.createObjectURL(file);
          const img = new Image();
          await new Promise((res,rej)=>{ img.onload=res; img.onerror=rej; img.src=url; });
          URL.revokeObjectURL(url);
          w = img.width; h = img.height;
          const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h;
          const tctx = tmp.getContext('2d', { willReadFrequently:true });
          tctx.drawImage(img,0,0);
          const id = tctx.getImageData(0,0,w,h).data;
          let grayscale = true;
          for (let i=0;i<id.length;i+=4){
            if (id[i]!==id[i+1] || id[i]!==id[i+2]){ grayscale=false; break; }
          }
          if (grayscale){
            labels = new Uint32Array(w*h);
            for (let j=0,i=0;j<w*h;j++,i+=4) labels[j] = id[i];
          } else {
            const rgb = new Uint8Array(w*h*3);
            for (let j=0,i=0,k=0;j<w*h;j++,i+=4,k+=3){ rgb[k]=id[i]; rgb[k+1]=id[i+1]; rgb[k+2]=id[i+2]; }
            labels = colorToLabelsFromInterleavedRGB(rgb, w, h);
          }
        } else {
          setStatus('Unsupported mask type. Use TIFF or PNG.');
          return;
        }

        const { fillBitmap, edgeBitmap } = await buildMaskBitmaps(labels, w, h);

        mask = {
          w, h, labels,
          fillBitmap, edgeBitmap,
          opacity: (+maskOpacityEl.value)/100,
          showFill: maskShowFillEl.checked,
          showEdges: maskShowEdgesEl.checked
        };
        if (!dapiBitmap) setPivotToImageCenter();
        setStatus(`Mask loaded ${w}×${h}`);
        redraw();
      } catch(err){
        console.error(err);
        setStatus('Failed to load mask: '+(err?.message||err));
      }
    }

    function colorToLabelsFromInterleavedRGB(rgb, w, h){
      const N = w*h;
      const labels = new Uint32Array(N);
      const map = new Map(); // color->label
      let next = 1;
      for (let j=0,k=0;j<N;j++,k+=3){
        const key = (rgb[k]<<16) | (rgb[k+1]<<8) | (rgb[k+2]);
        if (key === 0){ labels[j]=0; continue; } // black as background
        let lab = map.get(key);
        if (!lab){ lab = next++; map.set(key, lab); }
        labels[j] = lab;
      }
      return labels;
    }

    async function buildMaskBitmaps(labels, w, h){
      function labelColor(l){
        const h = (l * 137.508) % 360;
        const s = 70, L = 55;
        return hslToRgb(h/360, s/100, L/100); // [r,g,b]
      }

      // Fill bitmap
      const c1 = document.createElement('canvas'); c1.width=w; c1.height=h;
      const g1 = c1.getContext('2d', { willReadFrequently:true });
      const id1 = g1.createImageData(w,h);
      for (let j=0,i=0;j<w*h;j++,i+=4){
        const lab = labels[j];
        if (lab===0){ id1.data[i+3]=0; continue; }
        const [r,g,b] = labelColor(lab);
        id1.data[i]=r; id1.data[i+1]=g; id1.data[i+2]=b; id1.data[i+3]=255;
      }
      g1.putImageData(id1,0,0);
      const fillBitmap = await createImageBitmap(c1);

      // Edge bitmap
      const c2 = document.createElement('canvas'); c2.width=w; c2.height=h;
      const g2 = c2.getContext('2d', { willReadFrequently:true });
      const id2 = g2.createImageData(w,h);
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          const idx = y*w + x;
          const lab = labels[idx];
          if (lab===0) continue;
          let edge=false;
          if (x+1<w && labels[idx+1]!==lab) edge=true;
          else if (y+1<h && labels[idx+w]!==lab) edge=true;
          else if (x>0 && labels[idx-1]!==lab) edge=true;
          else if (y>0 && labels[idx-w]!==lab) edge=true;
          if (edge){
            const i = idx*4;
            id2.data[i]=255; id2.data[i+1]=255; id2.data[i+2]=255; id2.data[i+3]=255;
          }
        }
      }
      g2.putImageData(id2,0,0);
      const edgeBitmap = await createImageBitmap(c2);

      return { fillBitmap, edgeBitmap };
    }

    // ---------- Fit / Reset ----------
    function ensureCanvasSize(){
      const r = container.getBoundingClientRect();
      [dapiCanvas, maskCanvas, ptsCanvas, polyCanvas].forEach(c=>{
        if (c.width !== r.width || c.height !== r.height){
          c.width  = r.width;
          c.height = r.height;
          c.style.width  = r.width+'px';
          c.style.height = r.height+'px';
        }
      });
    }
    function fitView(resetAngle=false){
      ensureCanvasSize();
      if (!(dapiW && dapiH)){
        scale = 1; offX = 0; offY = 0;
        if (resetAngle) angle = 0;
        if (mask){ pivot.x = mask.w/2; pivot.y = mask.h/2; }
        return;
      }
      if (resetAngle) angle = 0;

      const cw = dapiCanvas.width, ch = dapiCanvas.height;
      const iw = dapiW, ih = dapiH;

      const sx = cw / iw, sy = ch / ih;
      scale = Math.min(sx, sy) * 0.95;

      const drawW = iw * scale, drawH = ih * scale;
      offX = Math.round((cw - drawW)/2);
      offY = Math.round((ch - drawH)/2);

      pivot.x = iw/2;
      pivot.y = ih/2;
    }

    function setPivotToImageCenter(){
      if (dapiW && dapiH){
        pivot.x = dapiW  / 2;
        pivot.y = dapiH / 2;
      } else if (mask){
        pivot.x = mask.w / 2;
        pivot.y = mask.h / 2;
      } else {
        const wx0 = (-offX) / scale, wy0 = (-offY) / scale;
        const wx1 = (polyCanvas.width  - offX) / scale;
        const wy1 = (polyCanvas.height - offY) / scale;
        pivot.x = (wx0 + wx1) / 2;
        pivot.y = (wy0 + wy1) / 2;
      }
    }

    // ---------- Color helpers ----------
    function hslToRgb(h, s, l){
      if (s===0) { const v = Math.round(l*255); return [v,v,v]; }
      const q = l < 0.5 ? l*(1+s) : l + s - l*s;
      const p = 2*l - q;
      const r = hue2rgb(p,q,h+1/3);
      const g = hue2rgb(p,q,h);
      const b = hue2rgb(p,q,h-1/3);
      return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
    }
    function hue2rgb(p,q,t){
      if (t<0) t+=1; if (t>1) t-=1;
      if (t<1/6) return p + (q-p)*6*t;
      if (t<1/2) return q;
      if (t<2/3) return p + (q-p)*(2/3 - t)*6;
      return p;
    }
    function randColorHex(){
      const h = Math.floor(Math.random()*360);
      const [r,g,b] = hslToRgb(h/360, 0.9, 0.6);
      const toHex = v => v.toString(16).padStart(2,'0');
      return '#' + toHex(r) + toHex(g) + toHex(b);
    }

    // ---------- Init ----------
    resize();
  })();
  </script>
</body>
</html>
